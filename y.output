Terminals unused in grammar

   BOOLEAN


State 59 conflicts: 6 reduce/reduce
State 60 conflicts: 8 shift/reduce
State 130 conflicts: 9 shift/reduce
State 133 conflicts: 8 shift/reduce, 15 reduce/reduce


Grammar

    0 $accept: program $end

    1 program: decl_list funct_def decl_and_def_list

    2 decl_list: decl_list var_decl
    3          | decl_list const_decl
    4          | decl_list funct_decl
    5          | %empty

    6 decl_and_def_list: decl_and_def_list var_decl
    7                  | decl_and_def_list const_decl
    8                  | decl_and_def_list funct_decl
    9                  | decl_and_def_list funct_def
   10                  | %empty

   11 $@1: %empty

   12 funct_def: scalar_type ID L_PAREN R_PAREN $@1 compound_statement

   13 $@2: %empty

   14 funct_def: scalar_type ID L_PAREN parameter_list R_PAREN $@2 compound_statement

   15 $@3: %empty

   16 funct_def: VOID ID L_PAREN R_PAREN $@3 compound_statement

   17 $@4: %empty

   18 funct_def: VOID ID L_PAREN parameter_list R_PAREN $@4 compound_statement

   19 funct_decl: scalar_type ID L_PAREN R_PAREN SEMICOLON
   20           | scalar_type ID L_PAREN parameter_list R_PAREN SEMICOLON
   21           | VOID ID L_PAREN R_PAREN SEMICOLON
   22           | VOID ID L_PAREN parameter_list R_PAREN SEMICOLON

   23 parameter_list: parameter_list COMMA scalar_type ID
   24               | parameter_list COMMA scalar_type array_decl
   25               | scalar_type array_decl
   26               | scalar_type ID

   27 var_decl: scalar_type identifier_list SEMICOLON

   28 identifier_list: identifier_list COMMA ID
   29                | identifier_list COMMA ID ASSIGN_OP logical_expression
   30                | identifier_list COMMA array_decl ASSIGN_OP initial_array
   31                | identifier_list COMMA array_decl
   32                | array_decl ASSIGN_OP initial_array
   33                | array_decl
   34                | ID ASSIGN_OP logical_expression
   35                | ID

   36 initial_array: L_BRACE literal_list R_BRACE

   37 literal_list: literal_list COMMA logical_expression
   38             | logical_expression
   39             | %empty

   40 const_decl: CONST scalar_type const_list SEMICOLON

   41 const_list: const_list COMMA ID ASSIGN_OP literal_const
   42           | ID ASSIGN_OP literal_const

   43 array_decl: ID dim

   44 dim: dim ML_BRACE INT_CONST MR_BRACE
   45    | ML_BRACE INT_CONST MR_BRACE

   46 $@5: %empty

   47 compound_statement: $@5 L_BRACE var_const_stmt_list R_BRACE

   48 var_const_stmt_list: var_const_stmt_list statement
   49                    | var_const_stmt_list var_decl
   50                    | var_const_stmt_list const_decl
   51                    | %empty

   52 statement: compound_statement
   53          | simple_statement
   54          | conditional_statement
   55          | while_statement
   56          | for_statement
   57          | function_invoke_statement
   58          | jump_statement

   59 simple_statement: variable_reference ASSIGN_OP logical_expression SEMICOLON
   60                 | PRINT logical_expression SEMICOLON
   61                 | READ variable_reference SEMICOLON

   62 conditional_statement: IF L_PAREN conditional_if R_PAREN compound_statement
   63                      | IF L_PAREN conditional_if R_PAREN compound_statement ELSE compound_statement

   64 conditional_if: logical_expression

   65 $@6: %empty

   66 $@7: %empty

   67 while_statement: WHILE L_PAREN logical_expression $@6 R_PAREN $@7 compound_statement

   68 $@8: %empty

   69 while_statement: $@8 DO compound_statement WHILE L_PAREN logical_expression R_PAREN SEMICOLON

   70 $@9: %empty

   71 for_statement: FOR L_PAREN initial_expression SEMICOLON control_expression SEMICOLON increment_expression R_PAREN $@9 compound_statement

   72 initial_expression: initial_expression COMMA statement_for
   73                   | initial_expression COMMA logical_expression
   74                   | logical_expression
   75                   | statement_for
   76                   | %empty

   77 control_expression: control_expression COMMA statement_for
   78                   | control_expression COMMA logical_expression
   79                   | logical_expression
   80                   | statement_for
   81                   | %empty

   82 increment_expression: increment_expression COMMA statement_for
   83                     | increment_expression COMMA logical_expression
   84                     | logical_expression
   85                     | statement_for
   86                     | %empty

   87 statement_for: variable_reference ASSIGN_OP logical_expression

   88 function_invoke_statement: ID L_PAREN logical_expression_list R_PAREN SEMICOLON
   89                          | ID L_PAREN R_PAREN SEMICOLON

   90 jump_statement: CONTINUE SEMICOLON
   91               | BREAK SEMICOLON
   92               | RETURN logical_expression SEMICOLON

   93 variable_reference: ID
   94                   | variable_reference dimension

   95 dimension: ML_BRACE arithmetic_expression MR_BRACE

   96 logical_expression: logical_expression OR_OP logical_term
   97                   | logical_term

   98 logical_term: logical_term AND_OP logical_factor
   99             | logical_factor

  100 logical_factor: NOT_OP logical_factor
  101               | relation_expression

  102 relation_expression: arithmetic_expression relation_operator arithmetic_expression
  103                    | arithmetic_expression

  104 relation_operator: LT_OP
  105                  | LE_OP
  106                  | EQ_OP
  107                  | GE_OP
  108                  | GT_OP
  109                  | NE_OP

  110 arithmetic_expression: arithmetic_expression add_op term
  111                      | relation_expression
  112                      | term

  113 add_op: ADD_OP
  114       | SUB_OP

  115 term: term mul_op factor
  116     | factor

  117 mul_op: MUL_OP
  118       | DIV_OP
  119       | MOD_OP

  120 factor: variable_reference
  121       | SUB_OP variable_reference
  122       | L_PAREN logical_expression R_PAREN
  123       | SUB_OP L_PAREN logical_expression R_PAREN
  124       | ID L_PAREN logical_expression_list R_PAREN
  125       | SUB_OP ID L_PAREN logical_expression_list R_PAREN
  126       | ID L_PAREN R_PAREN
  127       | SUB_OP ID L_PAREN R_PAREN
  128       | literal_const

  129 logical_expression_list: logical_expression_list COMMA logical_expression
  130                        | logical_expression

  131 scalar_type: INT
  132            | DOUBLE
  133            | STRING
  134            | BOOL
  135            | FLOAT

  136 literal_const: INT_CONST
  137              | SUB_OP INT_CONST
  138              | FLOAT_CONST
  139              | SUB_OP FLOAT_CONST
  140              | SCIENTIFIC
  141              | SUB_OP SCIENTIFIC
  142              | STR_CONST
  143              | TRUE
  144              | FALSE


Terminals, with rules where they appear

$end (0) 0
error (256)
LE_OP (258) 105
NE_OP (259) 109
GE_OP (260) 107
EQ_OP (261) 106
AND_OP (262) 98
OR_OP (263) 96
READ (264) 61
BOOLEAN (265)
WHILE (266) 67 69
DO (267) 69
IF (268) 62 63
ELSE (269) 63
TRUE (270) 143
FALSE (271) 144
FOR (272) 71
INT (273) 131
PRINT (274) 60
BOOL (275) 134
VOID (276) 16 18 21 22
FLOAT (277) 135
DOUBLE (278) 132
STRING (279) 133
CONTINUE (280) 90
BREAK (281) 91
RETURN (282) 92
CONST (283) 40
L_PAREN (284) 12 14 16 18 19 20 21 22 62 63 67 69 71 88 89 122 123
    124 125 126 127
R_PAREN (285) 12 14 16 18 19 20 21 22 62 63 67 69 71 88 89 122 123
    124 125 126 127
COMMA (286) 23 24 28 29 30 31 37 41 72 73 77 78 82 83 129
SEMICOLON (287) 19 20 21 22 27 40 59 60 61 69 71 88 89 90 91 92
ML_BRACE (288) 44 45 95
MR_BRACE (289) 44 45 95
L_BRACE (290) 36 47
R_BRACE (291) 36 47
ADD_OP (292) 113
SUB_OP (293) 114 121 123 125 127 137 139 141
MUL_OP (294) 117
DIV_OP (295) 118
MOD_OP (296) 119
ASSIGN_OP (297) 29 30 32 34 41 42 59 87
LT_OP (298) 104
GT_OP (299) 108
NOT_OP (300) 100
ID (301) 12 14 16 18 19 20 21 22 23 26 28 29 34 35 41 42 43 88 89 93
    124 125 126 127
INT_CONST (302) 44 45 136 137
FLOAT_CONST (303) 138 139
SCIENTIFIC (304) 140 141
STR_CONST (305) 142


Nonterminals, with rules where they appear

$accept (51)
    on left: 0
program (52)
    on left: 1, on right: 0
decl_list (53)
    on left: 2 3 4 5, on right: 1 2 3 4
decl_and_def_list (54)
    on left: 6 7 8 9 10, on right: 1 6 7 8 9
funct_def (55)
    on left: 12 14 16 18, on right: 1 9
$@1 (56)
    on left: 11, on right: 12
$@2 (57)
    on left: 13, on right: 14
$@3 (58)
    on left: 15, on right: 16
$@4 (59)
    on left: 17, on right: 18
funct_decl (60)
    on left: 19 20 21 22, on right: 4 8
parameter_list (61)
    on left: 23 24 25 26, on right: 14 18 20 22 23 24
var_decl (62)
    on left: 27, on right: 2 6 49
identifier_list (63)
    on left: 28 29 30 31 32 33 34 35, on right: 27 28 29 30 31
initial_array (64)
    on left: 36, on right: 30 32
literal_list (65)
    on left: 37 38 39, on right: 36 37
const_decl (66)
    on left: 40, on right: 3 7 50
const_list (67)
    on left: 41 42, on right: 40 41
array_decl (68)
    on left: 43, on right: 24 25 30 31 32 33
dim (69)
    on left: 44 45, on right: 43 44
compound_statement (70)
    on left: 47, on right: 12 14 16 18 52 62 63 67 69 71
$@5 (71)
    on left: 46, on right: 47
var_const_stmt_list (72)
    on left: 48 49 50 51, on right: 47 48 49 50
statement (73)
    on left: 52 53 54 55 56 57 58, on right: 48
simple_statement (74)
    on left: 59 60 61, on right: 53
conditional_statement (75)
    on left: 62 63, on right: 54
conditional_if (76)
    on left: 64, on right: 62 63
while_statement (77)
    on left: 67 69, on right: 55
$@6 (78)
    on left: 65, on right: 67
$@7 (79)
    on left: 66, on right: 67
$@8 (80)
    on left: 68, on right: 69
for_statement (81)
    on left: 71, on right: 56
$@9 (82)
    on left: 70, on right: 71
initial_expression (83)
    on left: 72 73 74 75 76, on right: 71 72 73
control_expression (84)
    on left: 77 78 79 80 81, on right: 71 77 78
increment_expression (85)
    on left: 82 83 84 85 86, on right: 71 82 83
statement_for (86)
    on left: 87, on right: 72 75 77 80 82 85
function_invoke_statement (87)
    on left: 88 89, on right: 57
jump_statement (88)
    on left: 90 91 92, on right: 58
variable_reference (89)
    on left: 93 94, on right: 59 61 87 94 120 121
dimension (90)
    on left: 95, on right: 94
logical_expression (91)
    on left: 96 97, on right: 29 34 37 38 59 60 64 67 69 73 74 78 79
    83 84 87 92 96 122 123 129 130
logical_term (92)
    on left: 98 99, on right: 96 97 98
logical_factor (93)
    on left: 100 101, on right: 98 99 100
relation_expression (94)
    on left: 102 103, on right: 101 111
relation_operator (95)
    on left: 104 105 106 107 108 109, on right: 102
arithmetic_expression (96)
    on left: 110 111 112, on right: 95 102 103 110
add_op (97)
    on left: 113 114, on right: 110
term (98)
    on left: 115 116, on right: 110 112 115
mul_op (99)
    on left: 117 118 119, on right: 115
factor (100)
    on left: 120 121 122 123 124 125 126 127 128, on right: 115 116
logical_expression_list (101)
    on left: 129 130, on right: 88 124 125 129
scalar_type (102)
    on left: 131 132 133 134 135, on right: 12 14 19 20 23 24 25 26
    27 40
literal_const (103)
    on left: 136 137 138 139 140 141 142 143 144, on right: 41 42 128


State 0

    0 $accept: . program $end

    $default  reduce using rule 5 (decl_list)

    program    go to state 1
    decl_list  go to state 2


State 1

    0 $accept: program . $end

    $end  shift, and go to state 3


State 2

    1 program: decl_list . funct_def decl_and_def_list
    2 decl_list: decl_list . var_decl
    3          | decl_list . const_decl
    4          | decl_list . funct_decl

    INT     shift, and go to state 4
    BOOL    shift, and go to state 5
    VOID    shift, and go to state 6
    FLOAT   shift, and go to state 7
    DOUBLE  shift, and go to state 8
    STRING  shift, and go to state 9
    CONST   shift, and go to state 10

    funct_def    go to state 11
    funct_decl   go to state 12
    var_decl     go to state 13
    const_decl   go to state 14
    scalar_type  go to state 15


State 3

    0 $accept: program $end .

    $default  accept


State 4

  131 scalar_type: INT .

    $default  reduce using rule 131 (scalar_type)


State 5

  134 scalar_type: BOOL .

    $default  reduce using rule 134 (scalar_type)


State 6

   16 funct_def: VOID . ID L_PAREN R_PAREN $@3 compound_statement
   18          | VOID . ID L_PAREN parameter_list R_PAREN $@4 compound_statement
   21 funct_decl: VOID . ID L_PAREN R_PAREN SEMICOLON
   22           | VOID . ID L_PAREN parameter_list R_PAREN SEMICOLON

    ID  shift, and go to state 16


State 7

  135 scalar_type: FLOAT .

    $default  reduce using rule 135 (scalar_type)


State 8

  132 scalar_type: DOUBLE .

    $default  reduce using rule 132 (scalar_type)


State 9

  133 scalar_type: STRING .

    $default  reduce using rule 133 (scalar_type)


State 10

   40 const_decl: CONST . scalar_type const_list SEMICOLON

    INT     shift, and go to state 4
    BOOL    shift, and go to state 5
    FLOAT   shift, and go to state 7
    DOUBLE  shift, and go to state 8
    STRING  shift, and go to state 9

    scalar_type  go to state 17


State 11

    1 program: decl_list funct_def . decl_and_def_list

    $default  reduce using rule 10 (decl_and_def_list)

    decl_and_def_list  go to state 18


State 12

    4 decl_list: decl_list funct_decl .

    $default  reduce using rule 4 (decl_list)


State 13

    2 decl_list: decl_list var_decl .

    $default  reduce using rule 2 (decl_list)


State 14

    3 decl_list: decl_list const_decl .

    $default  reduce using rule 3 (decl_list)


State 15

   12 funct_def: scalar_type . ID L_PAREN R_PAREN $@1 compound_statement
   14          | scalar_type . ID L_PAREN parameter_list R_PAREN $@2 compound_statement
   19 funct_decl: scalar_type . ID L_PAREN R_PAREN SEMICOLON
   20           | scalar_type . ID L_PAREN parameter_list R_PAREN SEMICOLON
   27 var_decl: scalar_type . identifier_list SEMICOLON

    ID  shift, and go to state 19

    identifier_list  go to state 20
    array_decl       go to state 21


State 16

   16 funct_def: VOID ID . L_PAREN R_PAREN $@3 compound_statement
   18          | VOID ID . L_PAREN parameter_list R_PAREN $@4 compound_statement
   21 funct_decl: VOID ID . L_PAREN R_PAREN SEMICOLON
   22           | VOID ID . L_PAREN parameter_list R_PAREN SEMICOLON

    L_PAREN  shift, and go to state 22


State 17

   40 const_decl: CONST scalar_type . const_list SEMICOLON

    ID  shift, and go to state 23

    const_list  go to state 24


State 18

    1 program: decl_list funct_def decl_and_def_list .
    6 decl_and_def_list: decl_and_def_list . var_decl
    7                  | decl_and_def_list . const_decl
    8                  | decl_and_def_list . funct_decl
    9                  | decl_and_def_list . funct_def

    INT     shift, and go to state 4
    BOOL    shift, and go to state 5
    VOID    shift, and go to state 6
    FLOAT   shift, and go to state 7
    DOUBLE  shift, and go to state 8
    STRING  shift, and go to state 9
    CONST   shift, and go to state 10

    $default  reduce using rule 1 (program)

    funct_def    go to state 25
    funct_decl   go to state 26
    var_decl     go to state 27
    const_decl   go to state 28
    scalar_type  go to state 15


State 19

   12 funct_def: scalar_type ID . L_PAREN R_PAREN $@1 compound_statement
   14          | scalar_type ID . L_PAREN parameter_list R_PAREN $@2 compound_statement
   19 funct_decl: scalar_type ID . L_PAREN R_PAREN SEMICOLON
   20           | scalar_type ID . L_PAREN parameter_list R_PAREN SEMICOLON
   34 identifier_list: ID . ASSIGN_OP logical_expression
   35                | ID .
   43 array_decl: ID . dim

    L_PAREN    shift, and go to state 29
    ML_BRACE   shift, and go to state 30
    ASSIGN_OP  shift, and go to state 31

    $default  reduce using rule 35 (identifier_list)

    dim  go to state 32


State 20

   27 var_decl: scalar_type identifier_list . SEMICOLON
   28 identifier_list: identifier_list . COMMA ID
   29                | identifier_list . COMMA ID ASSIGN_OP logical_expression
   30                | identifier_list . COMMA array_decl ASSIGN_OP initial_array
   31                | identifier_list . COMMA array_decl

    COMMA      shift, and go to state 33
    SEMICOLON  shift, and go to state 34


State 21

   32 identifier_list: array_decl . ASSIGN_OP initial_array
   33                | array_decl .

    ASSIGN_OP  shift, and go to state 35

    $default  reduce using rule 33 (identifier_list)


State 22

   16 funct_def: VOID ID L_PAREN . R_PAREN $@3 compound_statement
   18          | VOID ID L_PAREN . parameter_list R_PAREN $@4 compound_statement
   21 funct_decl: VOID ID L_PAREN . R_PAREN SEMICOLON
   22           | VOID ID L_PAREN . parameter_list R_PAREN SEMICOLON

    INT      shift, and go to state 4
    BOOL     shift, and go to state 5
    FLOAT    shift, and go to state 7
    DOUBLE   shift, and go to state 8
    STRING   shift, and go to state 9
    R_PAREN  shift, and go to state 36

    parameter_list  go to state 37
    scalar_type     go to state 38


State 23

   42 const_list: ID . ASSIGN_OP literal_const

    ASSIGN_OP  shift, and go to state 39


State 24

   40 const_decl: CONST scalar_type const_list . SEMICOLON
   41 const_list: const_list . COMMA ID ASSIGN_OP literal_const

    COMMA      shift, and go to state 40
    SEMICOLON  shift, and go to state 41


State 25

    9 decl_and_def_list: decl_and_def_list funct_def .

    $default  reduce using rule 9 (decl_and_def_list)


State 26

    8 decl_and_def_list: decl_and_def_list funct_decl .

    $default  reduce using rule 8 (decl_and_def_list)


State 27

    6 decl_and_def_list: decl_and_def_list var_decl .

    $default  reduce using rule 6 (decl_and_def_list)


State 28

    7 decl_and_def_list: decl_and_def_list const_decl .

    $default  reduce using rule 7 (decl_and_def_list)


State 29

   12 funct_def: scalar_type ID L_PAREN . R_PAREN $@1 compound_statement
   14          | scalar_type ID L_PAREN . parameter_list R_PAREN $@2 compound_statement
   19 funct_decl: scalar_type ID L_PAREN . R_PAREN SEMICOLON
   20           | scalar_type ID L_PAREN . parameter_list R_PAREN SEMICOLON

    INT      shift, and go to state 4
    BOOL     shift, and go to state 5
    FLOAT    shift, and go to state 7
    DOUBLE   shift, and go to state 8
    STRING   shift, and go to state 9
    R_PAREN  shift, and go to state 42

    parameter_list  go to state 43
    scalar_type     go to state 38


State 30

   45 dim: ML_BRACE . INT_CONST MR_BRACE

    INT_CONST  shift, and go to state 44


State 31

   34 identifier_list: ID ASSIGN_OP . logical_expression

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    variable_reference     go to state 55
    logical_expression     go to state 56
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 32

   43 array_decl: ID dim .
   44 dim: dim . ML_BRACE INT_CONST MR_BRACE

    ML_BRACE  shift, and go to state 64

    $default  reduce using rule 43 (array_decl)


State 33

   28 identifier_list: identifier_list COMMA . ID
   29                | identifier_list COMMA . ID ASSIGN_OP logical_expression
   30                | identifier_list COMMA . array_decl ASSIGN_OP initial_array
   31                | identifier_list COMMA . array_decl

    ID  shift, and go to state 65

    array_decl  go to state 66


State 34

   27 var_decl: scalar_type identifier_list SEMICOLON .

    $default  reduce using rule 27 (var_decl)


State 35

   32 identifier_list: array_decl ASSIGN_OP . initial_array

    L_BRACE  shift, and go to state 67

    initial_array  go to state 68


State 36

   16 funct_def: VOID ID L_PAREN R_PAREN . $@3 compound_statement
   21 funct_decl: VOID ID L_PAREN R_PAREN . SEMICOLON

    SEMICOLON  shift, and go to state 69

    $default  reduce using rule 15 ($@3)

    $@3  go to state 70


State 37

   18 funct_def: VOID ID L_PAREN parameter_list . R_PAREN $@4 compound_statement
   22 funct_decl: VOID ID L_PAREN parameter_list . R_PAREN SEMICOLON
   23 parameter_list: parameter_list . COMMA scalar_type ID
   24               | parameter_list . COMMA scalar_type array_decl

    R_PAREN  shift, and go to state 71
    COMMA    shift, and go to state 72


State 38

   25 parameter_list: scalar_type . array_decl
   26               | scalar_type . ID

    ID  shift, and go to state 73

    array_decl  go to state 74


State 39

   42 const_list: ID ASSIGN_OP . literal_const

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    SUB_OP       shift, and go to state 75
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    literal_const  go to state 76


State 40

   41 const_list: const_list COMMA . ID ASSIGN_OP literal_const

    ID  shift, and go to state 77


State 41

   40 const_decl: CONST scalar_type const_list SEMICOLON .

    $default  reduce using rule 40 (const_decl)


State 42

   12 funct_def: scalar_type ID L_PAREN R_PAREN . $@1 compound_statement
   19 funct_decl: scalar_type ID L_PAREN R_PAREN . SEMICOLON

    SEMICOLON  shift, and go to state 78

    $default  reduce using rule 11 ($@1)

    $@1  go to state 79


State 43

   14 funct_def: scalar_type ID L_PAREN parameter_list . R_PAREN $@2 compound_statement
   20 funct_decl: scalar_type ID L_PAREN parameter_list . R_PAREN SEMICOLON
   23 parameter_list: parameter_list . COMMA scalar_type ID
   24               | parameter_list . COMMA scalar_type array_decl

    R_PAREN  shift, and go to state 80
    COMMA    shift, and go to state 72


State 44

   45 dim: ML_BRACE INT_CONST . MR_BRACE

    MR_BRACE  shift, and go to state 81


State 45

  143 literal_const: TRUE .

    $default  reduce using rule 143 (literal_const)


State 46

  144 literal_const: FALSE .

    $default  reduce using rule 144 (literal_const)


State 47

  122 factor: L_PAREN . logical_expression R_PAREN

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    variable_reference     go to state 55
    logical_expression     go to state 82
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 48

  121 factor: SUB_OP . variable_reference
  123       | SUB_OP . L_PAREN logical_expression R_PAREN
  125       | SUB_OP . ID L_PAREN logical_expression_list R_PAREN
  127       | SUB_OP . ID L_PAREN R_PAREN
  137 literal_const: SUB_OP . INT_CONST
  139              | SUB_OP . FLOAT_CONST
  141              | SUB_OP . SCIENTIFIC

    L_PAREN      shift, and go to state 83
    ID           shift, and go to state 84
    INT_CONST    shift, and go to state 85
    FLOAT_CONST  shift, and go to state 86
    SCIENTIFIC   shift, and go to state 87

    variable_reference  go to state 88


State 49

  100 logical_factor: NOT_OP . logical_factor

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    variable_reference     go to state 55
    logical_factor         go to state 89
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 50

   93 variable_reference: ID .
  124 factor: ID . L_PAREN logical_expression_list R_PAREN
  126       | ID . L_PAREN R_PAREN

    L_PAREN  shift, and go to state 90

    $default  reduce using rule 93 (variable_reference)


State 51

  136 literal_const: INT_CONST .

    $default  reduce using rule 136 (literal_const)


State 52

  138 literal_const: FLOAT_CONST .

    $default  reduce using rule 138 (literal_const)


State 53

  140 literal_const: SCIENTIFIC .

    $default  reduce using rule 140 (literal_const)


State 54

  142 literal_const: STR_CONST .

    $default  reduce using rule 142 (literal_const)


State 55

   94 variable_reference: variable_reference . dimension
  120 factor: variable_reference .

    ML_BRACE  shift, and go to state 91

    $default  reduce using rule 120 (factor)

    dimension  go to state 92


State 56

   34 identifier_list: ID ASSIGN_OP logical_expression .
   96 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 93

    $default  reduce using rule 34 (identifier_list)


State 57

   97 logical_expression: logical_term .
   98 logical_term: logical_term . AND_OP logical_factor

    AND_OP  shift, and go to state 94

    $default  reduce using rule 97 (logical_expression)


State 58

   99 logical_term: logical_factor .

    $default  reduce using rule 99 (logical_term)


State 59

  101 logical_factor: relation_expression .
  111 arithmetic_expression: relation_expression .

    AND_OP     reduce using rule 101 (logical_factor)
    AND_OP     [reduce using rule 111 (arithmetic_expression)]
    OR_OP      reduce using rule 101 (logical_factor)
    OR_OP      [reduce using rule 111 (arithmetic_expression)]
    R_PAREN    reduce using rule 101 (logical_factor)
    R_PAREN    [reduce using rule 111 (arithmetic_expression)]
    COMMA      reduce using rule 101 (logical_factor)
    COMMA      [reduce using rule 111 (arithmetic_expression)]
    SEMICOLON  reduce using rule 101 (logical_factor)
    SEMICOLON  [reduce using rule 111 (arithmetic_expression)]
    R_BRACE    reduce using rule 101 (logical_factor)
    R_BRACE    [reduce using rule 111 (arithmetic_expression)]
    $default   reduce using rule 111 (arithmetic_expression)


State 60

  102 relation_expression: arithmetic_expression . relation_operator arithmetic_expression
  103                    | arithmetic_expression .
  110 arithmetic_expression: arithmetic_expression . add_op term

    LE_OP   shift, and go to state 95
    NE_OP   shift, and go to state 96
    GE_OP   shift, and go to state 97
    EQ_OP   shift, and go to state 98
    ADD_OP  shift, and go to state 99
    SUB_OP  shift, and go to state 100
    LT_OP   shift, and go to state 101
    GT_OP   shift, and go to state 102

    LE_OP     [reduce using rule 103 (relation_expression)]
    NE_OP     [reduce using rule 103 (relation_expression)]
    GE_OP     [reduce using rule 103 (relation_expression)]
    EQ_OP     [reduce using rule 103 (relation_expression)]
    ADD_OP    [reduce using rule 103 (relation_expression)]
    SUB_OP    [reduce using rule 103 (relation_expression)]
    LT_OP     [reduce using rule 103 (relation_expression)]
    GT_OP     [reduce using rule 103 (relation_expression)]
    $default  reduce using rule 103 (relation_expression)

    relation_operator  go to state 103
    add_op             go to state 104


State 61

  112 arithmetic_expression: term .
  115 term: term . mul_op factor

    MUL_OP  shift, and go to state 105
    DIV_OP  shift, and go to state 106
    MOD_OP  shift, and go to state 107

    $default  reduce using rule 112 (arithmetic_expression)

    mul_op  go to state 108


State 62

  116 term: factor .

    $default  reduce using rule 116 (term)


State 63

  128 factor: literal_const .

    $default  reduce using rule 128 (factor)


State 64

   44 dim: dim ML_BRACE . INT_CONST MR_BRACE

    INT_CONST  shift, and go to state 109


State 65

   28 identifier_list: identifier_list COMMA ID .
   29                | identifier_list COMMA ID . ASSIGN_OP logical_expression
   43 array_decl: ID . dim

    ML_BRACE   shift, and go to state 30
    ASSIGN_OP  shift, and go to state 110

    $default  reduce using rule 28 (identifier_list)

    dim  go to state 32


State 66

   30 identifier_list: identifier_list COMMA array_decl . ASSIGN_OP initial_array
   31                | identifier_list COMMA array_decl .

    ASSIGN_OP  shift, and go to state 111

    $default  reduce using rule 31 (identifier_list)


State 67

   36 initial_array: L_BRACE . literal_list R_BRACE

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    $default  reduce using rule 39 (literal_list)

    literal_list           go to state 112
    variable_reference     go to state 55
    logical_expression     go to state 113
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 68

   32 identifier_list: array_decl ASSIGN_OP initial_array .

    $default  reduce using rule 32 (identifier_list)


State 69

   21 funct_decl: VOID ID L_PAREN R_PAREN SEMICOLON .

    $default  reduce using rule 21 (funct_decl)


State 70

   16 funct_def: VOID ID L_PAREN R_PAREN $@3 . compound_statement

    $default  reduce using rule 46 ($@5)

    compound_statement  go to state 114
    $@5                 go to state 115


State 71

   18 funct_def: VOID ID L_PAREN parameter_list R_PAREN . $@4 compound_statement
   22 funct_decl: VOID ID L_PAREN parameter_list R_PAREN . SEMICOLON

    SEMICOLON  shift, and go to state 116

    $default  reduce using rule 17 ($@4)

    $@4  go to state 117


State 72

   23 parameter_list: parameter_list COMMA . scalar_type ID
   24               | parameter_list COMMA . scalar_type array_decl

    INT     shift, and go to state 4
    BOOL    shift, and go to state 5
    FLOAT   shift, and go to state 7
    DOUBLE  shift, and go to state 8
    STRING  shift, and go to state 9

    scalar_type  go to state 118


State 73

   26 parameter_list: scalar_type ID .
   43 array_decl: ID . dim

    ML_BRACE  shift, and go to state 30

    $default  reduce using rule 26 (parameter_list)

    dim  go to state 32


State 74

   25 parameter_list: scalar_type array_decl .

    $default  reduce using rule 25 (parameter_list)


State 75

  137 literal_const: SUB_OP . INT_CONST
  139              | SUB_OP . FLOAT_CONST
  141              | SUB_OP . SCIENTIFIC

    INT_CONST    shift, and go to state 85
    FLOAT_CONST  shift, and go to state 86
    SCIENTIFIC   shift, and go to state 87


State 76

   42 const_list: ID ASSIGN_OP literal_const .

    $default  reduce using rule 42 (const_list)


State 77

   41 const_list: const_list COMMA ID . ASSIGN_OP literal_const

    ASSIGN_OP  shift, and go to state 119


State 78

   19 funct_decl: scalar_type ID L_PAREN R_PAREN SEMICOLON .

    $default  reduce using rule 19 (funct_decl)


State 79

   12 funct_def: scalar_type ID L_PAREN R_PAREN $@1 . compound_statement

    $default  reduce using rule 46 ($@5)

    compound_statement  go to state 120
    $@5                 go to state 115


State 80

   14 funct_def: scalar_type ID L_PAREN parameter_list R_PAREN . $@2 compound_statement
   20 funct_decl: scalar_type ID L_PAREN parameter_list R_PAREN . SEMICOLON

    SEMICOLON  shift, and go to state 121

    $default  reduce using rule 13 ($@2)

    $@2  go to state 122


State 81

   45 dim: ML_BRACE INT_CONST MR_BRACE .

    $default  reduce using rule 45 (dim)


State 82

   96 logical_expression: logical_expression . OR_OP logical_term
  122 factor: L_PAREN logical_expression . R_PAREN

    OR_OP    shift, and go to state 93
    R_PAREN  shift, and go to state 123


State 83

  123 factor: SUB_OP L_PAREN . logical_expression R_PAREN

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    variable_reference     go to state 55
    logical_expression     go to state 124
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 84

   93 variable_reference: ID .
  125 factor: SUB_OP ID . L_PAREN logical_expression_list R_PAREN
  127       | SUB_OP ID . L_PAREN R_PAREN

    L_PAREN  shift, and go to state 125

    $default  reduce using rule 93 (variable_reference)


State 85

  137 literal_const: SUB_OP INT_CONST .

    $default  reduce using rule 137 (literal_const)


State 86

  139 literal_const: SUB_OP FLOAT_CONST .

    $default  reduce using rule 139 (literal_const)


State 87

  141 literal_const: SUB_OP SCIENTIFIC .

    $default  reduce using rule 141 (literal_const)


State 88

   94 variable_reference: variable_reference . dimension
  121 factor: SUB_OP variable_reference .

    ML_BRACE  shift, and go to state 91

    $default  reduce using rule 121 (factor)

    dimension  go to state 92


State 89

  100 logical_factor: NOT_OP logical_factor .

    $default  reduce using rule 100 (logical_factor)


State 90

  124 factor: ID L_PAREN . logical_expression_list R_PAREN
  126       | ID L_PAREN . R_PAREN

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    R_PAREN      shift, and go to state 126
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    variable_reference       go to state 55
    logical_expression       go to state 127
    logical_term             go to state 57
    logical_factor           go to state 58
    relation_expression      go to state 59
    arithmetic_expression    go to state 60
    term                     go to state 61
    factor                   go to state 62
    logical_expression_list  go to state 128
    literal_const            go to state 63


State 91

   95 dimension: ML_BRACE . arithmetic_expression MR_BRACE

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    variable_reference     go to state 55
    relation_expression    go to state 129
    arithmetic_expression  go to state 130
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 92

   94 variable_reference: variable_reference dimension .

    $default  reduce using rule 94 (variable_reference)


State 93

   96 logical_expression: logical_expression OR_OP . logical_term

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    variable_reference     go to state 55
    logical_term           go to state 131
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 94

   98 logical_term: logical_term AND_OP . logical_factor

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    variable_reference     go to state 55
    logical_factor         go to state 132
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 95

  105 relation_operator: LE_OP .

    $default  reduce using rule 105 (relation_operator)


State 96

  109 relation_operator: NE_OP .

    $default  reduce using rule 109 (relation_operator)


State 97

  107 relation_operator: GE_OP .

    $default  reduce using rule 107 (relation_operator)


State 98

  106 relation_operator: EQ_OP .

    $default  reduce using rule 106 (relation_operator)


State 99

  113 add_op: ADD_OP .

    $default  reduce using rule 113 (add_op)


State 100

  114 add_op: SUB_OP .

    $default  reduce using rule 114 (add_op)


State 101

  104 relation_operator: LT_OP .

    $default  reduce using rule 104 (relation_operator)


State 102

  108 relation_operator: GT_OP .

    $default  reduce using rule 108 (relation_operator)


State 103

  102 relation_expression: arithmetic_expression relation_operator . arithmetic_expression

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    variable_reference     go to state 55
    relation_expression    go to state 129
    arithmetic_expression  go to state 133
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 104

  110 arithmetic_expression: arithmetic_expression add_op . term

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    variable_reference  go to state 55
    term                go to state 134
    factor              go to state 62
    literal_const       go to state 63


State 105

  117 mul_op: MUL_OP .

    $default  reduce using rule 117 (mul_op)


State 106

  118 mul_op: DIV_OP .

    $default  reduce using rule 118 (mul_op)


State 107

  119 mul_op: MOD_OP .

    $default  reduce using rule 119 (mul_op)


State 108

  115 term: term mul_op . factor

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    variable_reference  go to state 55
    factor              go to state 135
    literal_const       go to state 63


State 109

   44 dim: dim ML_BRACE INT_CONST . MR_BRACE

    MR_BRACE  shift, and go to state 136


State 110

   29 identifier_list: identifier_list COMMA ID ASSIGN_OP . logical_expression

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    variable_reference     go to state 55
    logical_expression     go to state 137
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 111

   30 identifier_list: identifier_list COMMA array_decl ASSIGN_OP . initial_array

    L_BRACE  shift, and go to state 67

    initial_array  go to state 138


State 112

   36 initial_array: L_BRACE literal_list . R_BRACE
   37 literal_list: literal_list . COMMA logical_expression

    COMMA    shift, and go to state 139
    R_BRACE  shift, and go to state 140


State 113

   38 literal_list: logical_expression .
   96 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 93

    $default  reduce using rule 38 (literal_list)


State 114

   16 funct_def: VOID ID L_PAREN R_PAREN $@3 compound_statement .

    $default  reduce using rule 16 (funct_def)


State 115

   47 compound_statement: $@5 . L_BRACE var_const_stmt_list R_BRACE

    L_BRACE  shift, and go to state 141


State 116

   22 funct_decl: VOID ID L_PAREN parameter_list R_PAREN SEMICOLON .

    $default  reduce using rule 22 (funct_decl)


State 117

   18 funct_def: VOID ID L_PAREN parameter_list R_PAREN $@4 . compound_statement

    $default  reduce using rule 46 ($@5)

    compound_statement  go to state 142
    $@5                 go to state 115


State 118

   23 parameter_list: parameter_list COMMA scalar_type . ID
   24               | parameter_list COMMA scalar_type . array_decl

    ID  shift, and go to state 143

    array_decl  go to state 144


State 119

   41 const_list: const_list COMMA ID ASSIGN_OP . literal_const

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    SUB_OP       shift, and go to state 75
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    literal_const  go to state 145


State 120

   12 funct_def: scalar_type ID L_PAREN R_PAREN $@1 compound_statement .

    $default  reduce using rule 12 (funct_def)


State 121

   20 funct_decl: scalar_type ID L_PAREN parameter_list R_PAREN SEMICOLON .

    $default  reduce using rule 20 (funct_decl)


State 122

   14 funct_def: scalar_type ID L_PAREN parameter_list R_PAREN $@2 . compound_statement

    $default  reduce using rule 46 ($@5)

    compound_statement  go to state 146
    $@5                 go to state 115


State 123

  122 factor: L_PAREN logical_expression R_PAREN .

    $default  reduce using rule 122 (factor)


State 124

   96 logical_expression: logical_expression . OR_OP logical_term
  123 factor: SUB_OP L_PAREN logical_expression . R_PAREN

    OR_OP    shift, and go to state 93
    R_PAREN  shift, and go to state 147


State 125

  125 factor: SUB_OP ID L_PAREN . logical_expression_list R_PAREN
  127       | SUB_OP ID L_PAREN . R_PAREN

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    R_PAREN      shift, and go to state 148
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    variable_reference       go to state 55
    logical_expression       go to state 127
    logical_term             go to state 57
    logical_factor           go to state 58
    relation_expression      go to state 59
    arithmetic_expression    go to state 60
    term                     go to state 61
    factor                   go to state 62
    logical_expression_list  go to state 149
    literal_const            go to state 63


State 126

  126 factor: ID L_PAREN R_PAREN .

    $default  reduce using rule 126 (factor)


State 127

   96 logical_expression: logical_expression . OR_OP logical_term
  130 logical_expression_list: logical_expression .

    OR_OP  shift, and go to state 93

    $default  reduce using rule 130 (logical_expression_list)


State 128

  124 factor: ID L_PAREN logical_expression_list . R_PAREN
  129 logical_expression_list: logical_expression_list . COMMA logical_expression

    R_PAREN  shift, and go to state 150
    COMMA    shift, and go to state 151


State 129

  111 arithmetic_expression: relation_expression .

    $default  reduce using rule 111 (arithmetic_expression)


State 130

   95 dimension: ML_BRACE arithmetic_expression . MR_BRACE
  102 relation_expression: arithmetic_expression . relation_operator arithmetic_expression
  103                    | arithmetic_expression .
  110 arithmetic_expression: arithmetic_expression . add_op term

    LE_OP     shift, and go to state 95
    NE_OP     shift, and go to state 96
    GE_OP     shift, and go to state 97
    EQ_OP     shift, and go to state 98
    MR_BRACE  shift, and go to state 152
    ADD_OP    shift, and go to state 99
    SUB_OP    shift, and go to state 100
    LT_OP     shift, and go to state 101
    GT_OP     shift, and go to state 102

    LE_OP     [reduce using rule 103 (relation_expression)]
    NE_OP     [reduce using rule 103 (relation_expression)]
    GE_OP     [reduce using rule 103 (relation_expression)]
    EQ_OP     [reduce using rule 103 (relation_expression)]
    MR_BRACE  [reduce using rule 103 (relation_expression)]
    ADD_OP    [reduce using rule 103 (relation_expression)]
    SUB_OP    [reduce using rule 103 (relation_expression)]
    LT_OP     [reduce using rule 103 (relation_expression)]
    GT_OP     [reduce using rule 103 (relation_expression)]

    relation_operator  go to state 103
    add_op             go to state 104


State 131

   96 logical_expression: logical_expression OR_OP logical_term .
   98 logical_term: logical_term . AND_OP logical_factor

    AND_OP  shift, and go to state 94

    $default  reduce using rule 96 (logical_expression)


State 132

   98 logical_term: logical_term AND_OP logical_factor .

    $default  reduce using rule 98 (logical_term)


State 133

  102 relation_expression: arithmetic_expression . relation_operator arithmetic_expression
  102                    | arithmetic_expression relation_operator arithmetic_expression .
  103                    | arithmetic_expression .
  110 arithmetic_expression: arithmetic_expression . add_op term

    LE_OP   shift, and go to state 95
    NE_OP   shift, and go to state 96
    GE_OP   shift, and go to state 97
    EQ_OP   shift, and go to state 98
    ADD_OP  shift, and go to state 99
    SUB_OP  shift, and go to state 100
    LT_OP   shift, and go to state 101
    GT_OP   shift, and go to state 102

    LE_OP      [reduce using rule 102 (relation_expression)]
    LE_OP      [reduce using rule 103 (relation_expression)]
    NE_OP      [reduce using rule 102 (relation_expression)]
    NE_OP      [reduce using rule 103 (relation_expression)]
    GE_OP      [reduce using rule 102 (relation_expression)]
    GE_OP      [reduce using rule 103 (relation_expression)]
    EQ_OP      [reduce using rule 102 (relation_expression)]
    EQ_OP      [reduce using rule 103 (relation_expression)]
    AND_OP     reduce using rule 102 (relation_expression)
    AND_OP     [reduce using rule 103 (relation_expression)]
    OR_OP      reduce using rule 102 (relation_expression)
    OR_OP      [reduce using rule 103 (relation_expression)]
    R_PAREN    reduce using rule 102 (relation_expression)
    R_PAREN    [reduce using rule 103 (relation_expression)]
    COMMA      reduce using rule 102 (relation_expression)
    COMMA      [reduce using rule 103 (relation_expression)]
    SEMICOLON  reduce using rule 102 (relation_expression)
    SEMICOLON  [reduce using rule 103 (relation_expression)]
    MR_BRACE   reduce using rule 102 (relation_expression)
    MR_BRACE   [reduce using rule 103 (relation_expression)]
    R_BRACE    reduce using rule 102 (relation_expression)
    R_BRACE    [reduce using rule 103 (relation_expression)]
    ADD_OP     [reduce using rule 102 (relation_expression)]
    ADD_OP     [reduce using rule 103 (relation_expression)]
    SUB_OP     [reduce using rule 102 (relation_expression)]
    SUB_OP     [reduce using rule 103 (relation_expression)]
    LT_OP      [reduce using rule 102 (relation_expression)]
    LT_OP      [reduce using rule 103 (relation_expression)]
    GT_OP      [reduce using rule 102 (relation_expression)]
    GT_OP      [reduce using rule 103 (relation_expression)]
    $default   reduce using rule 102 (relation_expression)

    relation_operator  go to state 103
    add_op             go to state 104


State 134

  110 arithmetic_expression: arithmetic_expression add_op term .
  115 term: term . mul_op factor

    MUL_OP  shift, and go to state 105
    DIV_OP  shift, and go to state 106
    MOD_OP  shift, and go to state 107

    $default  reduce using rule 110 (arithmetic_expression)

    mul_op  go to state 108


State 135

  115 term: term mul_op factor .

    $default  reduce using rule 115 (term)


State 136

   44 dim: dim ML_BRACE INT_CONST MR_BRACE .

    $default  reduce using rule 44 (dim)


State 137

   29 identifier_list: identifier_list COMMA ID ASSIGN_OP logical_expression .
   96 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 93

    $default  reduce using rule 29 (identifier_list)


State 138

   30 identifier_list: identifier_list COMMA array_decl ASSIGN_OP initial_array .

    $default  reduce using rule 30 (identifier_list)


State 139

   37 literal_list: literal_list COMMA . logical_expression

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    variable_reference     go to state 55
    logical_expression     go to state 153
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 140

   36 initial_array: L_BRACE literal_list R_BRACE .

    $default  reduce using rule 36 (initial_array)


State 141

   47 compound_statement: $@5 L_BRACE . var_const_stmt_list R_BRACE

    $default  reduce using rule 51 (var_const_stmt_list)

    var_const_stmt_list  go to state 154


State 142

   18 funct_def: VOID ID L_PAREN parameter_list R_PAREN $@4 compound_statement .

    $default  reduce using rule 18 (funct_def)


State 143

   23 parameter_list: parameter_list COMMA scalar_type ID .
   43 array_decl: ID . dim

    ML_BRACE  shift, and go to state 30

    $default  reduce using rule 23 (parameter_list)

    dim  go to state 32


State 144

   24 parameter_list: parameter_list COMMA scalar_type array_decl .

    $default  reduce using rule 24 (parameter_list)


State 145

   41 const_list: const_list COMMA ID ASSIGN_OP literal_const .

    $default  reduce using rule 41 (const_list)


State 146

   14 funct_def: scalar_type ID L_PAREN parameter_list R_PAREN $@2 compound_statement .

    $default  reduce using rule 14 (funct_def)


State 147

  123 factor: SUB_OP L_PAREN logical_expression R_PAREN .

    $default  reduce using rule 123 (factor)


State 148

  127 factor: SUB_OP ID L_PAREN R_PAREN .

    $default  reduce using rule 127 (factor)


State 149

  125 factor: SUB_OP ID L_PAREN logical_expression_list . R_PAREN
  129 logical_expression_list: logical_expression_list . COMMA logical_expression

    R_PAREN  shift, and go to state 155
    COMMA    shift, and go to state 151


State 150

  124 factor: ID L_PAREN logical_expression_list R_PAREN .

    $default  reduce using rule 124 (factor)


State 151

  129 logical_expression_list: logical_expression_list COMMA . logical_expression

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    variable_reference     go to state 55
    logical_expression     go to state 156
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 152

   95 dimension: ML_BRACE arithmetic_expression MR_BRACE .

    $default  reduce using rule 95 (dimension)


State 153

   37 literal_list: literal_list COMMA logical_expression .
   96 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 93

    $default  reduce using rule 37 (literal_list)


State 154

   47 compound_statement: $@5 L_BRACE var_const_stmt_list . R_BRACE
   48 var_const_stmt_list: var_const_stmt_list . statement
   49                    | var_const_stmt_list . var_decl
   50                    | var_const_stmt_list . const_decl

    READ      shift, and go to state 157
    WHILE     shift, and go to state 158
    IF        shift, and go to state 159
    FOR       shift, and go to state 160
    INT       shift, and go to state 4
    PRINT     shift, and go to state 161
    BOOL      shift, and go to state 5
    FLOAT     shift, and go to state 7
    DOUBLE    shift, and go to state 8
    STRING    shift, and go to state 9
    CONTINUE  shift, and go to state 162
    BREAK     shift, and go to state 163
    RETURN    shift, and go to state 164
    CONST     shift, and go to state 10
    R_BRACE   shift, and go to state 165
    ID        shift, and go to state 166

    DO        reduce using rule 68 ($@8)
    $default  reduce using rule 46 ($@5)

    var_decl                   go to state 167
    const_decl                 go to state 168
    compound_statement         go to state 169
    $@5                        go to state 115
    statement                  go to state 170
    simple_statement           go to state 171
    conditional_statement      go to state 172
    while_statement            go to state 173
    $@8                        go to state 174
    for_statement              go to state 175
    function_invoke_statement  go to state 176
    jump_statement             go to state 177
    variable_reference         go to state 178
    scalar_type                go to state 179


State 155

  125 factor: SUB_OP ID L_PAREN logical_expression_list R_PAREN .

    $default  reduce using rule 125 (factor)


State 156

   96 logical_expression: logical_expression . OR_OP logical_term
  129 logical_expression_list: logical_expression_list COMMA logical_expression .

    OR_OP  shift, and go to state 93

    $default  reduce using rule 129 (logical_expression_list)


State 157

   61 simple_statement: READ . variable_reference SEMICOLON

    ID  shift, and go to state 180

    variable_reference  go to state 181


State 158

   67 while_statement: WHILE . L_PAREN logical_expression $@6 R_PAREN $@7 compound_statement

    L_PAREN  shift, and go to state 182


State 159

   62 conditional_statement: IF . L_PAREN conditional_if R_PAREN compound_statement
   63                      | IF . L_PAREN conditional_if R_PAREN compound_statement ELSE compound_statement

    L_PAREN  shift, and go to state 183


State 160

   71 for_statement: FOR . L_PAREN initial_expression SEMICOLON control_expression SEMICOLON increment_expression R_PAREN $@9 compound_statement

    L_PAREN  shift, and go to state 184


State 161

   60 simple_statement: PRINT . logical_expression SEMICOLON

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    variable_reference     go to state 55
    logical_expression     go to state 185
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 162

   90 jump_statement: CONTINUE . SEMICOLON

    SEMICOLON  shift, and go to state 186


State 163

   91 jump_statement: BREAK . SEMICOLON

    SEMICOLON  shift, and go to state 187


State 164

   92 jump_statement: RETURN . logical_expression SEMICOLON

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    variable_reference     go to state 55
    logical_expression     go to state 188
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 165

   47 compound_statement: $@5 L_BRACE var_const_stmt_list R_BRACE .

    $default  reduce using rule 47 (compound_statement)


State 166

   88 function_invoke_statement: ID . L_PAREN logical_expression_list R_PAREN SEMICOLON
   89                          | ID . L_PAREN R_PAREN SEMICOLON
   93 variable_reference: ID .

    L_PAREN  shift, and go to state 189

    $default  reduce using rule 93 (variable_reference)


State 167

   49 var_const_stmt_list: var_const_stmt_list var_decl .

    $default  reduce using rule 49 (var_const_stmt_list)


State 168

   50 var_const_stmt_list: var_const_stmt_list const_decl .

    $default  reduce using rule 50 (var_const_stmt_list)


State 169

   52 statement: compound_statement .

    $default  reduce using rule 52 (statement)


State 170

   48 var_const_stmt_list: var_const_stmt_list statement .

    $default  reduce using rule 48 (var_const_stmt_list)


State 171

   53 statement: simple_statement .

    $default  reduce using rule 53 (statement)


State 172

   54 statement: conditional_statement .

    $default  reduce using rule 54 (statement)


State 173

   55 statement: while_statement .

    $default  reduce using rule 55 (statement)


State 174

   69 while_statement: $@8 . DO compound_statement WHILE L_PAREN logical_expression R_PAREN SEMICOLON

    DO  shift, and go to state 190


State 175

   56 statement: for_statement .

    $default  reduce using rule 56 (statement)


State 176

   57 statement: function_invoke_statement .

    $default  reduce using rule 57 (statement)


State 177

   58 statement: jump_statement .

    $default  reduce using rule 58 (statement)


State 178

   59 simple_statement: variable_reference . ASSIGN_OP logical_expression SEMICOLON
   94 variable_reference: variable_reference . dimension

    ML_BRACE   shift, and go to state 91
    ASSIGN_OP  shift, and go to state 191

    dimension  go to state 92


State 179

   27 var_decl: scalar_type . identifier_list SEMICOLON

    ID  shift, and go to state 192

    identifier_list  go to state 20
    array_decl       go to state 21


State 180

   93 variable_reference: ID .

    $default  reduce using rule 93 (variable_reference)


State 181

   61 simple_statement: READ variable_reference . SEMICOLON
   94 variable_reference: variable_reference . dimension

    SEMICOLON  shift, and go to state 193
    ML_BRACE   shift, and go to state 91

    dimension  go to state 92


State 182

   67 while_statement: WHILE L_PAREN . logical_expression $@6 R_PAREN $@7 compound_statement

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    variable_reference     go to state 55
    logical_expression     go to state 194
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 183

   62 conditional_statement: IF L_PAREN . conditional_if R_PAREN compound_statement
   63                      | IF L_PAREN . conditional_if R_PAREN compound_statement ELSE compound_statement

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    conditional_if         go to state 195
    variable_reference     go to state 55
    logical_expression     go to state 196
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 184

   71 for_statement: FOR L_PAREN . initial_expression SEMICOLON control_expression SEMICOLON increment_expression R_PAREN $@9 compound_statement

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    $default  reduce using rule 76 (initial_expression)

    initial_expression     go to state 197
    statement_for          go to state 198
    variable_reference     go to state 199
    logical_expression     go to state 200
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 185

   60 simple_statement: PRINT logical_expression . SEMICOLON
   96 logical_expression: logical_expression . OR_OP logical_term

    OR_OP      shift, and go to state 93
    SEMICOLON  shift, and go to state 201


State 186

   90 jump_statement: CONTINUE SEMICOLON .

    $default  reduce using rule 90 (jump_statement)


State 187

   91 jump_statement: BREAK SEMICOLON .

    $default  reduce using rule 91 (jump_statement)


State 188

   92 jump_statement: RETURN logical_expression . SEMICOLON
   96 logical_expression: logical_expression . OR_OP logical_term

    OR_OP      shift, and go to state 93
    SEMICOLON  shift, and go to state 202


State 189

   88 function_invoke_statement: ID L_PAREN . logical_expression_list R_PAREN SEMICOLON
   89                          | ID L_PAREN . R_PAREN SEMICOLON

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    R_PAREN      shift, and go to state 203
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    variable_reference       go to state 55
    logical_expression       go to state 127
    logical_term             go to state 57
    logical_factor           go to state 58
    relation_expression      go to state 59
    arithmetic_expression    go to state 60
    term                     go to state 61
    factor                   go to state 62
    logical_expression_list  go to state 204
    literal_const            go to state 63


State 190

   69 while_statement: $@8 DO . compound_statement WHILE L_PAREN logical_expression R_PAREN SEMICOLON

    $default  reduce using rule 46 ($@5)

    compound_statement  go to state 205
    $@5                 go to state 115


State 191

   59 simple_statement: variable_reference ASSIGN_OP . logical_expression SEMICOLON

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    variable_reference     go to state 55
    logical_expression     go to state 206
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 192

   34 identifier_list: ID . ASSIGN_OP logical_expression
   35                | ID .
   43 array_decl: ID . dim

    ML_BRACE   shift, and go to state 30
    ASSIGN_OP  shift, and go to state 31

    $default  reduce using rule 35 (identifier_list)

    dim  go to state 32


State 193

   61 simple_statement: READ variable_reference SEMICOLON .

    $default  reduce using rule 61 (simple_statement)


State 194

   67 while_statement: WHILE L_PAREN logical_expression . $@6 R_PAREN $@7 compound_statement
   96 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 93

    $default  reduce using rule 65 ($@6)

    $@6  go to state 207


State 195

   62 conditional_statement: IF L_PAREN conditional_if . R_PAREN compound_statement
   63                      | IF L_PAREN conditional_if . R_PAREN compound_statement ELSE compound_statement

    R_PAREN  shift, and go to state 208


State 196

   64 conditional_if: logical_expression .
   96 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 93

    $default  reduce using rule 64 (conditional_if)


State 197

   71 for_statement: FOR L_PAREN initial_expression . SEMICOLON control_expression SEMICOLON increment_expression R_PAREN $@9 compound_statement
   72 initial_expression: initial_expression . COMMA statement_for
   73                   | initial_expression . COMMA logical_expression

    COMMA      shift, and go to state 209
    SEMICOLON  shift, and go to state 210


State 198

   75 initial_expression: statement_for .

    $default  reduce using rule 75 (initial_expression)


State 199

   87 statement_for: variable_reference . ASSIGN_OP logical_expression
   94 variable_reference: variable_reference . dimension
  120 factor: variable_reference .

    ML_BRACE   shift, and go to state 91
    ASSIGN_OP  shift, and go to state 211

    $default  reduce using rule 120 (factor)

    dimension  go to state 92


State 200

   74 initial_expression: logical_expression .
   96 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 93

    $default  reduce using rule 74 (initial_expression)


State 201

   60 simple_statement: PRINT logical_expression SEMICOLON .

    $default  reduce using rule 60 (simple_statement)


State 202

   92 jump_statement: RETURN logical_expression SEMICOLON .

    $default  reduce using rule 92 (jump_statement)


State 203

   89 function_invoke_statement: ID L_PAREN R_PAREN . SEMICOLON

    SEMICOLON  shift, and go to state 212


State 204

   88 function_invoke_statement: ID L_PAREN logical_expression_list . R_PAREN SEMICOLON
  129 logical_expression_list: logical_expression_list . COMMA logical_expression

    R_PAREN  shift, and go to state 213
    COMMA    shift, and go to state 151


State 205

   69 while_statement: $@8 DO compound_statement . WHILE L_PAREN logical_expression R_PAREN SEMICOLON

    WHILE  shift, and go to state 214


State 206

   59 simple_statement: variable_reference ASSIGN_OP logical_expression . SEMICOLON
   96 logical_expression: logical_expression . OR_OP logical_term

    OR_OP      shift, and go to state 93
    SEMICOLON  shift, and go to state 215


State 207

   67 while_statement: WHILE L_PAREN logical_expression $@6 . R_PAREN $@7 compound_statement

    R_PAREN  shift, and go to state 216


State 208

   62 conditional_statement: IF L_PAREN conditional_if R_PAREN . compound_statement
   63                      | IF L_PAREN conditional_if R_PAREN . compound_statement ELSE compound_statement

    $default  reduce using rule 46 ($@5)

    compound_statement  go to state 217
    $@5                 go to state 115


State 209

   72 initial_expression: initial_expression COMMA . statement_for
   73                   | initial_expression COMMA . logical_expression

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    statement_for          go to state 218
    variable_reference     go to state 199
    logical_expression     go to state 219
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 210

   71 for_statement: FOR L_PAREN initial_expression SEMICOLON . control_expression SEMICOLON increment_expression R_PAREN $@9 compound_statement

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    $default  reduce using rule 81 (control_expression)

    control_expression     go to state 220
    statement_for          go to state 221
    variable_reference     go to state 199
    logical_expression     go to state 222
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 211

   87 statement_for: variable_reference ASSIGN_OP . logical_expression

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    variable_reference     go to state 55
    logical_expression     go to state 223
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 212

   89 function_invoke_statement: ID L_PAREN R_PAREN SEMICOLON .

    $default  reduce using rule 89 (function_invoke_statement)


State 213

   88 function_invoke_statement: ID L_PAREN logical_expression_list R_PAREN . SEMICOLON

    SEMICOLON  shift, and go to state 224


State 214

   69 while_statement: $@8 DO compound_statement WHILE . L_PAREN logical_expression R_PAREN SEMICOLON

    L_PAREN  shift, and go to state 225


State 215

   59 simple_statement: variable_reference ASSIGN_OP logical_expression SEMICOLON .

    $default  reduce using rule 59 (simple_statement)


State 216

   67 while_statement: WHILE L_PAREN logical_expression $@6 R_PAREN . $@7 compound_statement

    $default  reduce using rule 66 ($@7)

    $@7  go to state 226


State 217

   62 conditional_statement: IF L_PAREN conditional_if R_PAREN compound_statement .
   63                      | IF L_PAREN conditional_if R_PAREN compound_statement . ELSE compound_statement

    ELSE  shift, and go to state 227

    $default  reduce using rule 62 (conditional_statement)


State 218

   72 initial_expression: initial_expression COMMA statement_for .

    $default  reduce using rule 72 (initial_expression)


State 219

   73 initial_expression: initial_expression COMMA logical_expression .
   96 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 93

    $default  reduce using rule 73 (initial_expression)


State 220

   71 for_statement: FOR L_PAREN initial_expression SEMICOLON control_expression . SEMICOLON increment_expression R_PAREN $@9 compound_statement
   77 control_expression: control_expression . COMMA statement_for
   78                   | control_expression . COMMA logical_expression

    COMMA      shift, and go to state 228
    SEMICOLON  shift, and go to state 229


State 221

   80 control_expression: statement_for .

    $default  reduce using rule 80 (control_expression)


State 222

   79 control_expression: logical_expression .
   96 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 93

    $default  reduce using rule 79 (control_expression)


State 223

   87 statement_for: variable_reference ASSIGN_OP logical_expression .
   96 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 93

    $default  reduce using rule 87 (statement_for)


State 224

   88 function_invoke_statement: ID L_PAREN logical_expression_list R_PAREN SEMICOLON .

    $default  reduce using rule 88 (function_invoke_statement)


State 225

   69 while_statement: $@8 DO compound_statement WHILE L_PAREN . logical_expression R_PAREN SEMICOLON

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    variable_reference     go to state 55
    logical_expression     go to state 230
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 226

   67 while_statement: WHILE L_PAREN logical_expression $@6 R_PAREN $@7 . compound_statement

    $default  reduce using rule 46 ($@5)

    compound_statement  go to state 231
    $@5                 go to state 115


State 227

   63 conditional_statement: IF L_PAREN conditional_if R_PAREN compound_statement ELSE . compound_statement

    $default  reduce using rule 46 ($@5)

    compound_statement  go to state 232
    $@5                 go to state 115


State 228

   77 control_expression: control_expression COMMA . statement_for
   78                   | control_expression COMMA . logical_expression

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    statement_for          go to state 233
    variable_reference     go to state 199
    logical_expression     go to state 234
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 229

   71 for_statement: FOR L_PAREN initial_expression SEMICOLON control_expression SEMICOLON . increment_expression R_PAREN $@9 compound_statement

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    $default  reduce using rule 86 (increment_expression)

    increment_expression   go to state 235
    statement_for          go to state 236
    variable_reference     go to state 199
    logical_expression     go to state 237
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 230

   69 while_statement: $@8 DO compound_statement WHILE L_PAREN logical_expression . R_PAREN SEMICOLON
   96 logical_expression: logical_expression . OR_OP logical_term

    OR_OP    shift, and go to state 93
    R_PAREN  shift, and go to state 238


State 231

   67 while_statement: WHILE L_PAREN logical_expression $@6 R_PAREN $@7 compound_statement .

    $default  reduce using rule 67 (while_statement)


State 232

   63 conditional_statement: IF L_PAREN conditional_if R_PAREN compound_statement ELSE compound_statement .

    $default  reduce using rule 63 (conditional_statement)


State 233

   77 control_expression: control_expression COMMA statement_for .

    $default  reduce using rule 77 (control_expression)


State 234

   78 control_expression: control_expression COMMA logical_expression .
   96 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 93

    $default  reduce using rule 78 (control_expression)


State 235

   71 for_statement: FOR L_PAREN initial_expression SEMICOLON control_expression SEMICOLON increment_expression . R_PAREN $@9 compound_statement
   82 increment_expression: increment_expression . COMMA statement_for
   83                     | increment_expression . COMMA logical_expression

    R_PAREN  shift, and go to state 239
    COMMA    shift, and go to state 240


State 236

   85 increment_expression: statement_for .

    $default  reduce using rule 85 (increment_expression)


State 237

   84 increment_expression: logical_expression .
   96 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 93

    $default  reduce using rule 84 (increment_expression)


State 238

   69 while_statement: $@8 DO compound_statement WHILE L_PAREN logical_expression R_PAREN . SEMICOLON

    SEMICOLON  shift, and go to state 241


State 239

   71 for_statement: FOR L_PAREN initial_expression SEMICOLON control_expression SEMICOLON increment_expression R_PAREN . $@9 compound_statement

    $default  reduce using rule 70 ($@9)

    $@9  go to state 242


State 240

   82 increment_expression: increment_expression COMMA . statement_for
   83                     | increment_expression COMMA . logical_expression

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    statement_for          go to state 243
    variable_reference     go to state 199
    logical_expression     go to state 244
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 241

   69 while_statement: $@8 DO compound_statement WHILE L_PAREN logical_expression R_PAREN SEMICOLON .

    $default  reduce using rule 69 (while_statement)


State 242

   71 for_statement: FOR L_PAREN initial_expression SEMICOLON control_expression SEMICOLON increment_expression R_PAREN $@9 . compound_statement

    $default  reduce using rule 46 ($@5)

    compound_statement  go to state 245
    $@5                 go to state 115


State 243

   82 increment_expression: increment_expression COMMA statement_for .

    $default  reduce using rule 82 (increment_expression)


State 244

   83 increment_expression: increment_expression COMMA logical_expression .
   96 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 93

    $default  reduce using rule 83 (increment_expression)


State 245

   71 for_statement: FOR L_PAREN initial_expression SEMICOLON control_expression SEMICOLON increment_expression R_PAREN $@9 compound_statement .

    $default  reduce using rule 71 (for_statement)
